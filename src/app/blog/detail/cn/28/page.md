---
title: vue-ssr简析
id: vue-08
---

## vue-ssr
> vue服务端渲染，这是一种前后端同构方案，对于首屏渲染与seo友好，对于内容到达时间有要求的应用适用,但是会加重服务器负荷，需要做好相关的负载均衡
```
 1、由于没有动态更新，vue中的生命周期钩子函数中，只有beforeCreate与created会在ssr中调用
    像定时器的timer，在客户端里，可以在组件销毁的时候讲timer销毁，但是在服务器中，由于没有destroy，那么这个timer会一直存在

 2、服务器端与客户端的相应的API是不同的，可以将平台特定实现包含在通用api中。

 3、如果一些自定义指令直接操作dom，那么在ssr中可能报错。可以抽象为组件，运行在虚拟DOM级别，或者在创建服务器renderer时，使用directive选项提供服务器端版本

 4、需要为每个请求创建一个新的根vue实例，需要暴露一个重复执行的工厂函数
   const app = createApp(context);
   对于route，store和eventBus实例，不应该直接从模块导入到应用程序汇总，而是需要从createApp中创建一个新的实例，并从根vue实例注入

 5、如何将相同的vue应用程序提供给客户端呢？
   需要使用webpack打包vue应用。
   vue通常由webpack和vue-loader构建，但是许多webpack特定功能不能直接在node.js中使用（如file-loader导入文件）
   对于客户端代码，需要使用babel转换es6代码
   解决： 对于客户端与服务器端程序，都需要webpack打包。会产生服务器端与客户端版本

  6、代码分割
   应用程序的代码分割与都行加载，可以改善体积bundle的可交互时间。 对于初始屏来讲，“只加载所需”
   vue可以 使用 const Foo = () => import('./Foo.vue')类似的方式来加载异步组件
   //在vue2.5UI下，服务端渲染一部组件只能在路由组件，而2.5+以上异步组件可以在任何地方使用
   不过依然需要在挂载app之前调用router
  
  7、服务端渲染，如果应用依赖于一些异步数据，那么在开始渲染过程之前，需要预先取出与解析这数据
     子啊挂载到客户端之前，需要获取与服务端应用程序完全相同的数据，不然，会导致混合失败
     解决： 将获取的数据放置视图组件之外，专门的数据预取存储容器。 首先，服务端在渲染前取数据，将数据填充到store中，
     同时将在hTML中序列化与内联预置状态。 在挂载到客户端之前，可以直接从store中获取到内联预置状态
     这里使用Vuex
  8、通过访问路由，来决定获取哪些数据，也决定了哪些组件需要渲染。给定路由的数据，也是在该路由上渲染组件时所需的数据。 这样可以在路由组件上放置数据预取逻辑
     通过在路由组件上暴露出一个自定义静态函数asyncData， 函数在组件实例化之前调用，它无法访问this，需要将store和路由信息作为参数传递

  9、服务器端数据预取： 
    在entry-server.js中， 可以通过路由获取与router.getMatchedComponents()相匹配的组件，如果组件暴露出asyncData；
    就调用该方法，然后将解析完成的状态，附加到渲染上下文中
  10、客户端数据预取
    1、路由导航前解析数据: 应用程序等待视图所需数据解析完成后，再插入数据并处理当前视图。但是如果数据加载时间擦很难过，会让视图卡顿，可能需要数据加载指示器
    2、将数据预取逻辑放在视图组件的beforeMount函数中，当路由导航被触发时，可以立即切换视图。但是视图渲染时数据不完整。需要全局minxin的实现

  11、store代码拆分
   可以在路由组件的asyncData 钩子函数中，使用store.registerModule惰性注册模块
   由于模块时路由组件的依赖，那么将会被webpack移动到路由组件的异步chunk中

  12、客户端激活: 接管服务器发过来的静态html，将其变成Vue管理的动态DOM
     应用程序的根元素会有一个特殊的属性,data-server-rendered = "true" ,这会告知客户端vue这是服务器渲染的，应该以激活模式挂载
     开发模式下，vue会比较客户端生成的虚拟dom与服务器渲染的dom结构相比，如果不同，退出混合模式，丢弃现有dom从投渲染。但是生产情况下不会。
     对于一些html标签，在书写时要确保完整，如在服务器端的模板下table但是不加人tbody，但是浏览器会自动加入，但是vue虚拟dom会不包含。这样无法准确匹配。
  13、ssr问题
  node.js本身不支持source map, 每次编辑程序源代码后，都需要停止重启服务
  可以使用createBundleRenderer API，通过使用webpack插件，server bundle将生成可传递到bundle render的特殊JSON文件。
    这样可以：内置的source-map支持
            在开发过程甚至部署过程热加载
            关键的css注入支持自动内联在渲染过程中用到的组件所需css
            使用clientManifest进行资源注入：自动推断出最佳的预加载与预取指令，以及初始渲染所有的代码chunk

  14、构建配置：
    建议将配置分为base,client, server。 base包含两个环境共享的配置，如输出路径，别名和loader
    服务器配置和客户端配置可以通过webpack-merge来扩展配置

    clientManifest（客户端构建清单）：使用客户端清单与服务器bundle。render现在有了服务器/客户端的构架信息。从而可以自动推动与注入资源预加载，
    数据预取指令,以及css链接，script标签到所渲染你的html

  15、css管理：
  1、简单使用.vue文件组件内style
    好处:
      1、与html并列同级，组件作用域css
      2、能够使用预处理器或PostCSS
      3、开发过程中热重载
    同时vue-style-loader，具备一些服务器端渲染的特殊功能
      1、客户端与服务器端的通用编程体验
      2、使用bundleRenderer是，自动注入关键CSS
      3、通用css提取：
        支持使用extract-text-webpack-plugin将住chunk中的css提取到单独的css文件中。这样可以将文件分开缓存，可以用于UCUN在很多公用css中
        内部异步组件中的css将内联为js字符串，有vue-style-loader处理
  从vue文件中提取css,可以使用vue-loader的extractCss选项

    从NPM依赖模块导入css时需要注意几点：
     1、服务器端构建过程中，不应该外置化提取
     2、如果使用css提取+CommonChunkPlugin插件提取vendor，要避免在vendor.chunk中包含css文件

  HEAD管理：
    可以在组件的声明周期中，将数据动态第追加到渲染上下文，然后再模板中的占位符替换为这些数据
    高版本（2.3.2+）可以通过this.$ssrContext来直接访问组件中服务端渲染上下文

  缓存管理:
    虽然vue的ssr比较快，但是由于创建组件实例与虚拟dom的开销，比起基于字符串拼接的模板相比稍慢一些。引入缓存策略，可以减少服务器负载

    页面级别的缓存:
    如果一些页面需要相同内容，可以采用micro-caching缓存策略
    这个在Nginx层完成，在nodejs依然可实现它

    组件级别的缓存：
     需要在创建renderer时提供具体缓存实现方式，典型做法是传入 lru-cache
     可缓存的组件必须定义一个唯一的name选项，
     使用组件缓存的时机：
      1、 大的v-for列表重复出现的组件，其缓存策略可以使用其唯一的id加上最后更新的时间戳，来生成缓存键
     不适用的情况：
      1、具有可能依赖于全局状态的子组件
      2、具有对渲染上下文产生副作用的子组件
  流式渲染：
     在流式渲染模式下，当renderer遍历虚拟dom树时，会尽快发送数据，这样可以在获得第一个chunk时，就开始发送给客户端
     但是要等待流完成后，才能开始使用上下文数据。
     因此，如果上下文数据由组件生命周期钩子函数填充的，不建议使用流式传输。
```
